# +-------------------+
# | System Functions |
# +-----------------+

# Measures the speed of openning a new prompt
#promptspeed() {
#    for i in $(seq 1 10); do /usr/bin/time zsh -i -c exit; done
#}

# Generate SSH key
ssh-create() {
if [ ! -z "$1" ];
then
    ssh-keygen -f $HOME/.ssh/$1 -t rsa -N '' -C "$1"
    chmod 700 $HOME/.ssh/$1*
fi
}

# Command History
historystat() {
    history 0 | awk '{print $2}' | sort | uniq -c | sort -n -r | head
}

# +---------+
# | Display |
# +--------+

# Get Screen Resolution
screenres() {
    [ ! -z $1 ] && xrandr --current | grep '*' | awk '{print $1}' | line $1
}

# Screenshot
screenshot () {
    local DIR="${HOME}/Documents/images/screenshots"
    local DATE="$(date +%Y%m%d-%H%M%S)"
    local NAME="${DIR}/screenshot-${DATE}.png"
    local LOG="${DIR}/screenshots.log"

    # Check if the dir to store the screenshots exists, else create it:
    if [ ! -d "${DIR}" ]; then mkdir -p "${DIR}"; fi

    if [ ! -f "${LOG}" ]; then touch "${LOG}"; fi

    # Screenshot a selected window
    if [ "$1" = "win" ]; then import -format png "${NAME}"; fi

    # Screenshot the entire screen
    if [ "$1" = "scr" ]; then import -format png -window root "${NAME}"; fi

    # Screenshot a selected area
    if [ "$1" = "area" ]; then import -format png "${NAME}"; fi

    if [[ $# = 0 ]]; then
        # Display a warning if no area defined
        echo "No screenshot area has been specified. Please choose between: win, scr, area. Screenshot not taken."
        echo "${DATE}: No screenshot area has been defined. Screenshot not taken." >> "${LOG}"
    else
        # Save the screenshot in the directory and edit the log
        echo "${NAME}" >> "${LOG}"
    fi
}

# Screensaver [Matrix]
matrix () {
    local lines=$(tput lines)
    cols=$(tput cols)

    awkscript='
    {
        letters="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789@#$%^&*()"
        lines=$1
        random_col=$3
        c=$4
        letter=substr(letters,c,1)
        cols[random_col]=0;
        for (col in cols) {
            line=cols[col];
            cols[col]=cols[col]+1;
            printf "\033[%s;%sH\033[2;32m%s", line, col, letter;
            printf "\033[%s;%sH\033[1;37m%s\033[0;0H", cols[col], col, letter;
            if (cols[col] >= lines) {
                cols[col]=0;
            }
    }
}
'

echo -e "\e[1;40m"
clear

while :; do
    echo $lines $cols $(( $RANDOM % $cols)) $(( $RANDOM % 72 ))
    sleep 0.05
done | awk "$awkscript"
}

# +--------------------+
# | Directory Creation |
# +-------------------+

# Makes a directory with the given name and cd's into it
mkcd() {
    dir="$*";
    mkdir -p "$dir" && cd "$dir";
}

# Copies the choosen directory and makes another one with the given name
# and the same content
mkcp() {
    dir="$2"
    tmp="$2"; tmp="${tmp: -1}"
    [ "$tmp" != "/" ] && dir="$(dirname "$2")"
    [ -d "$dir" ] ||
    mkdir -p "$dir" &&
    cp -r "$@"
}

# Moves the current directory and its content and makes
# another one with the given name
mkmv() {
    dir="$2"
    tmp="$2"; tmp="${tmp: -1}"
    [ "$tmp" != "/" ] && dir="$(dirname "$2")"
    [ -d "$dir" ] ||
    mkdir -p "$dir" &&
    mv "$@"
}

# +-----------------------------+
# | File Extraction/Compression |
# +----------------------------+

# Extraction
extract() {
    if [ -f $1 ] ; then
        ex $1
    else
        echo "'$1' is not a valid file"
    fi
}

mkextract() {
    for file in "$@"
    do
        if [ -f $file ] ; then
            local filename=${file%\.*}
            mkdir -p $filename
            cp $file $filename
            cd $filename
            ex $file
            rm -f $file
            cd -
        else
            echo "'$1' is not a valid file"
        fi
    done
}

ex() {
    case $1 in
        *.tar.bz2)  tar xjf $1      ;;
        *.tar.gz)   tar xzf $1      ;;
        *.bz2)      bunzip2 $1      ;;
        *.gz)       gunzip $1       ;;
        *.tar)      tar xf $1       ;;
        *.tbz2)     tar xjf $1      ;;
        *.tgz)      tar xzf $1      ;;
        *.zip)      unzip $1        ;;
        *.7z)       7z x $1         ;; # require p7zip
        *.rar)      7z x $1         ;; # require p7zip
        *.iso)      7z x $1         ;; # require p7zip
        *.Z)        uncompress $1   ;;
        *)          echo "'$1' cannot be extracted" ;;
    esac
}

# Compression
compress() {
    tar cvzf $1.tar.gz $1
}

# +-----------------------------+
# | Image Edition |
# +----------------------------+

# Get the selected img size
imgsize() {
    local width=$(identify -format "%w" "$1")> /dev/null
    local height=$(identify -format "%h" "$1")> /dev/null

    echo -e "Size of $1: $width*$height"
}

# Resize the selected img
imgresize() {
    local filename=${1%\.*}
    local extension="${1##*.}"
    local separator="_"
    if [ ! -z $3 ]; then
        local finalName="$filename.$extension"
    else
        local finalName="$filename$separator$2.$extension"
    fi
    convert $1 -quality 100 -resize $2 $finalName
    echo "$finalName resized to $2"
}

# Resize imgs in batch
imgresizeall() {
    for f in *.${1}; do
        if [ ! -z $3 ]; then
            imgresize "$f" ${2} t
        else
            imgresize "$f" ${2}
        fi
    done
}

# Optimize img
imgoptimize() {
    local filename=${1%\.*}
    local extension="${1##*.}"
    local separator="_"
    local suffix="optimized"
    local finalName="$filename$separator$suffix.$extension"
    convert $1 -strip -interlace Plane -quality 85% $finalName
    echo "$finalName created"
}

Imgoptimize() {
    local filename=${1%\.*}
    local extension="${1##*.}"
    local separator="_"
    local suffix="optimized"
    local convert $1 -strip -interlace Plane -quality 85% $1
    echo "$1 created"
}

# Optmize imgs in batch
imgoptimizeall() {
    for f in *.${1}; do
        imgoptimize "$f"
    done
}

Imgoptimizeall() {
    for f in *.${1}; do
        Imgoptimize "$f"
    done
}

# Conver img to jpg
imgconvjpg() {
    if [ ! -z "$1" ];
    then
        local filename=${1%\.*}
        magick convert $1 "${filename}.jpg"
    else
        echo -e "You need to add an image to convert as param!"
    fi
}

# Conver img to png
imgconvpng() {
    if [ ! -z "$1" ];
    then
        local filename=${1%\.*}
        magick convert $1 "${filename}.png"
    else
        echo -e "You need to add an image to convert as param!"
    fi
}

# Convert img to webp
imgwebp() {
    local IMG_EXT="jpg"
    if [ ! -z $1 ];
    then
        IMG_EXT=$1
    fi
    for F in *.$IMG_EXT; do cwebp -q 100 $F -o `basename ${F%.$IMG_EXT}`.webp; done
}

# +----------------+
# | youtube-viewer |
# +---------------+

# Channel Search
yv-ch() {
    cat .yt-channels | sed -n "${1},${1}p" | awk -F- '{print $2}' | xargs youtube-viewer -sc
}

# Playlist Search
yv-pl() {
    cat .yt-channels | sed -n "${1},${1}p" | awk -F- '{print $3}' | xargs youtube-viewer -up
}

# Get the designated number of recent videos from Subscriptions
# (limited to 50, attention, this operation takes some time)
yvrc() {
    youtube-viewer -SV -results=${1}
}

# Download single video
ydl() {
    if [ ! -z $1 ];
    then
        youtube-dl -f 22 "$1"
    else
        echo "You need to specify a video url as argument"
    fi
}

# Download playlist
ydlp() {
    if [ ! -z $1 ];
    then
        youtube-dl -o "%(autonumber)s-%(title)s.%(ext)s" "$1"
    else
        echo "You need to specify a playlist url as argument"
    fi
}

# yt-download
#function ytvlc() {
#    URLS=(${(ps:\n:)"$(youtube-dl "$1" --get-url)"})
#    vlc "${URLS[1]}" --input-slave "${URLS[2]}"
#}
